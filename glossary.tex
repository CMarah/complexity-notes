\documentclass[12pt]{article}
\usepackage[margin=15mm]{geometry}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{bm}

\title{Mathematics and Computation Glossary}
\author{Carlos María Rodríguez}
\date{\today}

\newtheoremstyle{customdef}
  {5mm}%   Space above
  {0mm}%   Space below
  {\slshape}%  Body font
  {}%          Indent amount (empty = no indent, \parindent = para indent)
  {\bfseries}% Thm head font
  {.}%         Punctuation after thm head
  {0.5em}%     Space after thm head: " " = normal interword space;
  {}%          Thm head spec (can be left empty, meaning `normal')

\theoremstyle{customdef}
\newtheorem{defn}{Def.}[section]
\newtheorem{con}{Conjecture}[section]
\newtheorem{open}{Open Problem}[section]
\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]

\begin{document}
  \maketitle

  \section{Basics}

  \begin{defn}$\bm{I}$ denotes the set of all binary sequences of all lengths. $\bm{I_n}$ denotes
  the sequence of all binary sequences in $\bm{I}$, this is, $\bm{I_n} = \{0,1\}^n$.\end{defn}

  \begin{defn}(The class $\bm{\mathcal{P}}$). \\
    A function $f: \bm{I} \rightarrow \bm{I}$ is in the
    class $\mathcal{P}$ if there is an algorithm computing $f$ and positive constants, $A$,
    $c$, such that $\forall n \in \mathbb{N}, \forall x \in I_n$, the algorithm computes
    $f(x)$ in at most $An^c$ steps.
  \end{defn}

\begin{defn}(The class $\bm{\mathcal{NP}}$).\\
  The set $\mathcal{C} \in \bm{I}$ is in the class
    $\mathcal{NP}$ if there is a function $V_C \in \mathcal{P}$ and a constant $k \in
    \mathbb{R}$ such that:
    \begin{itemize}
      \item If $x \in \mathcal{C}$, then $\exists y \in \mathbb{R}$ with $|y| \leq
        k|x|^k$ and $V_C(x,y) = 1$.
      \item If $x \notin \mathcal{P}$, then $\forall y$ we have $V_C(x,y) = 0$.
    \end{itemize}
  \end{defn}
  The function $V_C$ is called the \emph{verification algorithm}, and the sequence $y$
  for which $V_C(x,y) = 1$ is called the \emph{witness}.


\begin{defn}(The class $\bm{co\mathcal{NP}}$).

  A set $\mathcal{C} \in \bm{I}$ is
    in the class $co\mathcal{NP}$ iff its complement
    $\bar{\mathcal{C}} = \bm{I} \setminus \mathcal{C}$ is in
$\mathcal{P}$.\end{defn}

  \begin{defn}(Efficient reductions).

    Let $C,D \subset \bm{I}$ be two classification
problems. $f: \bm{I} \rightarrow \bm{I}$ is an efficient reduction from $C$ to $D$ if
$f \in \mathcal{P}$ and $\forall x \in \bm{I}$ we have $x \in C \iff x \in D$.\end{defn}
We write $C \leq D$ if such a reduction exists.

\begin{defn}(Hardness and completeness).

  A problem $D$ is called $\mathcal{C}$-hard if $\forall C \in \mathcal{C}$,
we have $C \leq D$. If we further have that $D \in \mathcal{C}$, then $D$ is called
$\mathcal{C}$-complete.\end{defn}

\begin{defn}(The $SAT$ problem).\\
  Given a logical expression over Boolean variables (can take values in $\{0, 1\}$
  with connectives $\wedge, \vee, \neg$), is it satisfiable?
  This is, is there a boolean assignment of the variables trough which the expression
  evalutates to $1$? The set of all such expressions is denoted by $SAT$.
\end{defn}

\begin{thm}$SAT$ is $\mathcal{NP}$-complete.\end{thm}

\begin{defn}(The $2DIO$ problem).\\
  Given a Diophantine equations of the form $Ax^2 + By + C = 0; A,B,C \in \mathbb{Z}$,
  is it solvable with positive integers?
\end{defn}

\begin{thm}$2DIO$ is $\mathcal{NP}$-complete.\end{thm}

\begin{defn}(The $3COL$ problem).\\
  Given a planar map, can you color it using only 3 different colors?
\end{defn}

\begin{thm}$3COL$ is $\mathcal{NP}$-complete.\end{thm}

\begin{defn}(The $subset-sum$ problem).\\
  Given a sequence $a_1, a_2, ..., a_n \in \mathbb{Z}$ and $b$, is there a subset $J$ such
  that $\sum_{i \in J} a_i = b$?
\end{defn}

\begin{thm}$Subset-sum$ is $\mathcal{NP}$-complete.\end{thm}


\section{Problems and classes related to $\mathcal{NP}$}

Let us look at a few problem classes which do not fall into $\mathcal{NP}$ but which arise
naturally.

\begin{defn}(Optimization problems).\\
  Fix a $\mathcal{NP}$ problem and a cost function over solutions (witnesses). Given an
  input, find the \emph{best} solution for it (minimizes cost function).
\end{defn}

\begin{defn}(Quantified problems).\\
How does a problem from $\mathcal{NP}$ behave when parametrizing some of its variables?
For example, which Boolean expressions have have valid solutions when considering every
value possible for some given variables? The complexity class of all such problems
is called the \emph{Polynomial Hierarchy}, denoted $\mathcal{PH}$.
\end{defn}

\begin{defn}(Counting problems).\\
  For a given $\mathcal{NP}$ problem and an input, find the \emph{number} of solutions (witnesses).
  The class of these problems is denoted by $\#\mathcal{P}$.
\end{defn}

\begin{defn}(Strategic problems).\\
Given a (complete information, 2-player) game, find an optimal strategt for a given
player. The basic class for these problems is denoted by $\mathcal{PSP ACE}$,
solvable using a polynomial amount of space.\end{defn}

\begin{defn}(Total $\mathcal{NP}$ functions).\\
These are search problems seeking to find objects that are guaranteed to exist and are
certified by small witnesses. These kind of problems can be divided into multiple complexity
classes, lying between $\mathcal{P}$ and $\mathcal{NP}$. As examples:
\begin{itemize}
  \item Class $\mathcal{PLS}$, for polynomial local search.
  \item Class $\mathcal{PPAD}$, in which a problem consists in finding a fixed point for a
    given function.
  \item Computing a Nash equilibrium for a given 2-player game.
\end{itemize}
\end{defn}

\begin{thm}If $\mathcal{P} \neq \mathcal{NP}$, there are infinitely many levels of
difficuly in $\mathcal{NP}$.\end{thm}

Some examples of problems which we haven't been proven to be in $\mathcal{P}$ yet
aren't $\mathcal{NP}$-complete are:
\begin{itemize}
  \item Integer factoring.
  \item Knot triviality. Given a diagram describing a knot, is it the trivial knot?
  \item Graph isomorphism. Given two graphs, are they isomorphic
\end{itemize}

\begin{defn}(Constraint satisfaction problems, CSPs).\\
  Fixing arity $k$ (the locality parameter), alphabet $\Sigma$ (possible values for the
  variables), and a relation $R \subseteq \Sigma^k$ (defining the set of tuple values satifying
  the constrint).
  We denote by $CSP(k, \Sigma, R)$ the following computational problem. Given a collection
  of $k$-tuples from a set of $n$ variables, is there an assignment of the variables from
  $\Sigma^n$ that satisfies all constraints in $R$?
\end{defn}

\begin{thm}(Dichotomy theorem). Every CSP is either in $\mathcal{P}$ or is
$\mathcal{NP}$-complete.\end{thm}

\begin{defn}(Unique Games).\\
Fix $\epsilon > 0$ and integer $m$. The problem $UG(\epsilon, m)$ is the following.
The input is a system of linear equations in $n$ variables $x_1, x_2, x_3, ..., x_n$ over
$\mathbb{Z}_m$, with \emph{two} variables per equation. An algorithm must answer "yes" is
there is an assignment satisfying a fractoin $1 - \epsilon$ of the equations, and answer
"no" if no assignment satisfies more than a fraction $\epsilon$ of them, any answer is
acceptable if neither of these is the case.
\end{defn}
This is a specific case of CSP.

\begin{con}(UGC). For every $\epsilon > 0$ there exists $m$ such that $UG(\epsilon, m)$ is
  $\mathcal{NP}$-hard.
\end{con}

\begin{thm}Assume UGC. Then for every CSP, there is a constant $\delta$ such that
approximating it to within approximation ratio $\delta$ is in $\mathcal{P}$, but
approximating it to any better ratio $\delta + \epsilon$ is in $\mathcal{NP}$-hard for
every $\epsilon > 0$.
\end{thm}
\bigskip

In some cases we may want to study how a given problem behaves depending on how its inputs
are distributed, not only the worst-case scenarios. For example, we may be interested in
how difficult a given problem is \emph{on average}. One can generalize this notion
considering \emph{distributional} problems, given by $(C, D)$; $C$ is a classification
problem, and $D$ is a distribution on $\bm{I}$.
\begin{defn}(dist$\mathcal{P}$).\\
  We loosely define the distributional analog of $\mathcal{P}$, denoted by
  dist$\mathcal{P}$ as the set of problems having fast algorithms "on average".
\end{defn}

\begin{defn}(One-way function).\\
  A function $f: \bm{I} \rightarrow \bm{I}$ is called one-way if $f \in \mathcal{P}$, but
  for every efficient algorithm $A$, its probability of computing any pre-image of $f$
  applied to a random input is small. Namely, for every (large enough) $n$,
  $$Pr[f(A(f(x))) = f(x)] \leq \delta, \delta < 1$$
  where the probability is taken over the uniform distribution of n-bit sequences $x$.
\end{defn}
\bigskip

As an example, we may consider \emph{modular exponentiation}. Let $p$ be a prime, $g$ a
generator of $\mathbb{Z}_p^*$, and $ME_{p,g} : \{1,2,...,p-1\}\rightarrow\{1,2,...,p-1\}$,
given by $ME_{p,g}(x) = g^{x-1}$ mod $p$. Computing $ME_{p,g}$ is easy on every input, while it is
believed that computing the inverse of $ME_{p,g}$ for a well-selected $p$ is exponentially
hard. We can combine these permutations into a single permutation ME:$\bm{I} \rightarrow
\bm{I}$ and conjecture

\begin{con}The modular exponentiation function ME is a one-way function.\end{con}
\bigskip

A key observation is that the existence of any one-way function would imply that
dist$\mathcal{P} \neq $ dist$\mathcal{NP}$. In fact, it would prove that $\mathcal{NP} 
\cap co\mathcal{NP} \neq \mathcal{P}$.\\

Another important one-way function candidate is modular powering. Let $p, q$ be primes,
$N = pq$, and $c$ invertible modulo $\phi(N) = (p-1)(q-1)$. Define MP\textsubscript{N,c}
$: \mathbb{Z}_N \rightarrow \mathbb{Z}_N$ by MP\textsubscript{N,c}$(x) = x^c$ mod $N$. This
too is a permutation. Computing MP\textsubscript{N,c} is easy, but the inverse isn't. Once
again, we can construct a function MP$: \bm{I} \rightarrow \bm{I}$.

\begin{con}The modular powering function MP is a one-way function.\end{con}
The difference between ME and MP is that MP has a \emph{trap-door}: it becomes easy to
invert if one has the factors of $N$. This allows anyone who has the secret key (the prime
factors $p, q$) to restore the original message from a transformed one.


\section{Lower bounds, Boolean circuits, and attacks on $\mathcal{P}$ vs. $\mathcal{NP}$}

\begin{defn}(Boolean circuit).\\
A Boolean circuit may be viewed as the hardware analog of an algorithm. Computation of a
circuit on the Boolean inputs proceeds by applying a sequence of Boolean operations
(gates) to produce an output. The operations are AND, OR, and NOT.
\end{defn}

\begin{defn}(Circuit size).\\
For a finite function $g$, denote by $S(g))$ the size of the smallest Boolean circuit
computing $g$. More generally, for $f: \bm{I} \rightarrow \bm{I}$ with $f_n$ the
restriction of $f$ to inputs of size $n$, we define $S(f)$ to be the mapping from $n$ to
$S(f_n)$.
\end{defn}

\begin{defn}(The class $\mathcal{P}$/poly).\\
$\mathcal{P}$/poly is the set of all functions computable by a family of polynomial-size
circuits.
\end{defn}

\begin{thm}$\mathcal{P} \subseteq \mathcal{P}$/poly.\end{thm}

This is because a given $f_n$ function, one can simulate it's Turing machine, which runs
in polynomial time $T$, with a circuit $c_n$ whose size is $O((T(n))^2)$.

\begin{con} $\mathcal{NP} \nsubseteq \mathcal{P}$/poly. \end{con}

\begin{thm}For almost every function $f: \bm{I}_n \rightarrow \{0,1\}, S(f) \geq 2^{n/3}.$
\end{thm}
This is, most Boolean functions require exponential-size circuits. This can be seen by
considering that for a number $n$ of input bits, there are exactly $2^2^n$ functions,
while the number of different circuits of a given size $s$ is about $2^s^2$. Each circuit
computes a different function, so we must have $s > 2^{n/3}$ for most functions.\\
Sadly, this is a constructive proof, and we do not have any explicit function $f$ with this
property.

\begin{con} $S(SAT) = 2^{\Omega(n)}$.\end{con}

This conjecture is muth stronger than $\mathcal{P}$ vs. $\mathcal{NP}$, as it would imply
that SAT isn't in $\mathcal{P}$. But the fact is that \emph{not a single nontrivial
lower bound is known for a explicit function}. Formally,

\begin{open}Find an explicit function $f: \bm{I}_n \rightarrow \bm{I}_n$ for which $S(f)
\neq O(n)$.\end{open}
This means we are unable to provide any nontrivial lower bound, and we must turn to
restricted problems to find relevant results.
\bigskip

We first focus on Boolean formulas, with the set of de Morgan connectors.
\begin{defn}(Formula size).\\
  For a finite function $g: \bm{I}_n \rightarrow \{0,1\}$, denote by $L(g)$ the size of
  the smallest Boolean formula computing $g$. For $f: \bm{I} \rightarrow \{0,1\}$, with
  $f_n$ the restriction of $f$ to inputs of size $n$, we define $L(f)$ to be the mapping
  of $n$ to $L(f_n)$.
\end{defn}
This notion is univeral, as every Boolean function can be computed by a Boolean
formula. But, formulas are a worse computational model that circuits, and we can hope to
prove better lower bounds. As an example, $S$(PAR) $= O(n)$, while $L$(PAR) $= O(n²)$.

\begin{thm}There is a Boolean function f with $S(f) = O(n)$ and $L(f) =
\Omega(n^{3-o(1)})$.\end{thm}

The actual gap is believed to be exponential:

\begin{con}There is a Boolean function $f$ with $S(f) = O(n)$ and $L(f) \neq
n^{O(1)}$.\end{con}

\bigskip

\begin{defn}(CLIQUE problem).\\
  Given a graph on $n$ vertices, is there a complete subgraph of size $\sqrt{n}$?
\end{defn}
\begin{thm}CLIQUE is $\mathcal{NP}$-complete.\end{thm}

\begin{defn}(Perfect Matching problem).\\
  Given a graph, can you pair up the vertices so that every pair is connected by an edge?
\end{defn}
\begin{thm}Perfect matching is in $\mathcal{P}$\end{thm}


\begin{defn}(Monotone function).\\
A Boolean function is monotone if "increasing" the input (switching bits from 0 to 1) does
not decrease the function value.\end{defn}

CLIQUE is one of such functions: adding edges cannot remove a complete subgraph. A similar
reasoning can prove the same for Perfect matching.

\begin{defn}(Monotone circuit).\\
  A monotone circuit is one constructed only with the $\{\wedge, \vee\}$ gates.
\end{defn}
It can be shown that any monotone function can be computed by a monotone circuit.

\begin{defn}(Monotone formula).\\
  A monotone formula is one constructed only with the $\{\wedge, \vee\}$ operators.
\end{defn}

\begin{thm}CLIQUE requires exponential-size monotone circuits.\end{thm}

\begin{thm}Perfect matching requires super-polynomial-size monotone circuits.\end{thm}

\begin{thm}Perfect matching requires exponential-size monotone formulas.\end{thm}




\end{document}
